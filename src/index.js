var fs = require('fs');
var path = require('path');
var chalk = require('chalk');
var simpleGit = require('simple-git');
var normalize = require('normalize-path');
var findParentDir = require('find-parent-dir');
var aliases = require('./aliases.json');
var hooks = require('./hooks.json');
var pkg = require('../package.json');
var debugMode = false;

function confirmDebugMode(isDebug) {
	if (isDebug) {
		debugMode = true;
		console.log(chalk.yellow("Enabled Debug Mode"));
	}
}

function write(filename, data) {
	fs.writeFileSync(filename, data);
	fs.chmodSync(filename, parseInt('0755', 8));
}

function isGitvcsHook(filename) {
	var data = fs.readFileSync(filename, 'utf-8')
	return data.indexOf('#husky') !== -1
}

function getConfigAliasKeys() {
	var keys = [];
	for (var key in aliases) {
		keys.push(key);
	}
	return keys;
}

function isGhooks(filename) {
	var data = fs.readFileSync(filename, 'utf-8')
	return data.indexOf('// Generated by ghooks. Do not edit this file.') !== -1;
}

/**
 * Finds the Parent's Root Directory and verifies if
 * its a git repo. If so, it returns the path to git's
 * git-vcs directory.
 * @param   {[type]}  dirname  [description]
 * @return  {[type]}           [description]
 */
function findHooksDir(dirname) {
	var dir = findParentDir.sync(dirname, '.git');
	if (dir) {
		var gitDir = path.join(dir, '.git');
		var stats = fs.lstatSync(gitDir);
		if (stats.isFile()) {
			// Expect following format
			// git: pathToGit
			gitDir = fs.readFileSync(gitDir, 'utf-8').split(':')[1].trim();
			return path.join(dir, gitDir, 'hooks');
		}
		return path.join(gitDir, 'hooks');
	}
	return null;
}

function findAliases(dirname) {
	var dir = findParentDir.sync(dirname, '.git');
	if (dir) {
		var gitDir = path.join(dir, '.git');
		var gitConfig = path.join(gitDir, 'config');
		var stats = fs.lstatSync(gitConfig);
		if (stats.isFile()) {
			// Expect following format
			// git: pathToGit

			gitConfig = fs.readFileSync(gitConfig, 'utf-8');
			if (gitConfig.includes("[alias]")) {
				var aliases = gitConfig.split('[alias]')[1].trim();
				/** Check if The [alias] section is not empty */
				if (aliases) {
					return aliases;
				} else {
					/**
					 * [alias] section is empty, therefore remove it.
					 * If we dont do this, `.git/config` will begin to
					 * stack multiple empty [alias] sections.
					 */
					removeAliasSection(dirname);
				}
			}
			return "No Alias Section Found";
		}
	}
	return null;
}

function getHookScript(hookName, relativePath, cmd) {
	// On Windows normalize path (i.e. convert \ to /)
	var normalizedPath = normalize(relativePath);

	// Hook script
	var arr = [
	'#!/bin/sh',
	'#git-vcs ' + pkg.version,
	'',
	'command_exists () {',
	'  command -v "$1" >/dev/null 2>&1',
	'}',
	'',

	'load_nvm () {',
	'  export $1=$2',
	'  [ -s "$1/nvm.sh" ] && . $1/nvm.sh',
	'  exists nvm && [ -f .nvmrc ] && nvm use',
	'}',
	'',

	'has_hook_script () {',
	'  [ -f package.json ] && cat package.json | grep -q "\\"$1\\"[[:space:]]*:"',
	'}',
	''
	];

	arr = arr.concat([
		'cd ' + normalizedPath,
		'',
		'has_hook_script ' + cmd + ' || exit 0',
		''
		]);

	// On OS X and Linux, try to use nvm if it's installed
	if (process.platform !== 'win32') {
		// ~ is unavaible, so $HOME is used
		var home = process.env.HOME

		if (process.platform === 'darwin') {
			// Add
			// Brew standard installation path /use/local/bin
			// Node standard installation path /usr/local
			// for GUI apps
			arr = arr.concat([
				'export PATH=$PATH:/usr/local/bin:/usr/local'
				]);
		}

		if (process.platform === 'darwin') {
			arr = arr.concat([
				'command_exists npm || load_nvm BREW_NVM_DIR /usr/local/opt/nvm',
				''
				]);
		}

		arr = arr.concat([
			'command_exists npm || load_nvm NVM_DIR ' + home + '/.nvm',
			''
			]);
	} else {
		// Add
		// Node standard installation path /c/Program Files/nodejs
		// for GUI apps
		arr = arr.concat([
			'export PATH="$PATH:/c/Program Files/nodejs"'
			]);
	}

	// Can't find npm message
	var npmNotFound = '> hookers - Can\'t find npm in PATH. Skipping ' + cmd + ' script in package.json';

	arr = arr.concat([
		// Test if npm is in PATH
		'command_exists npm || {',
		'  echo >&2 "' + npmNotFound + '"',
		'  exit 0',
		'}',
		'',

		// Run script
		'echo',
		'echo "> hookers - npm run -s ' + cmd + '"',
		'echo',
		'',

		'export GIT_PARAMS="$*"',
		'npm run -s ' + cmd + ' || {',
		'  echo',
		'  echo "> hookers - ' + hookName + ' hook failed (add --no-verify to bypass)"',
		'  echo "> hookers - to debug, use \'npm run precommit\'"',
		'  exit 1',
		'}',
		''
		]);

	return arr.join('\n');
}

function createHook(hookersDir, gitHooksDir, hookName, cmd) {
	var filename = path.join(gitHooksDir, hookName);

	// Assuming that this file is in node_modules/hookers
	var packageDir = path.join(hookersDir, '..', '..');
	// If in debugMode, then reapply the packageDir value to local
	if (debugMode) {
		packageDir = path.join(hookersDir);
	}

	// Get project directory
	// When used in submodule, the project dir is the first .git that is found
	var projectDir = findParentDir.sync(hookersDir, '.git');

	// In order to support projects with package.json in a different directory
	// than .git, find relative path from project directory to package.json
	var relativePath = path.join('.', path.relative(projectDir, packageDir));

	var hookScript = getHookScript(hookName, relativePath, cmd);

	// Create hooks directory if needed
	if (!fs.existsSync(gitHooksDir)) {
		fs.mkdirSync(gitHooksDir);
	}

	if (!fs.existsSync(filename)) {
		return write(filename, hookScript);
	}

	if (isGhooks(filename)) {
		console.log('migrating ghooks ' + hookName + ' script');
		return write(filename, hookScript);
	}

	if (isGitvcsHook(filename)) {
		return write(filename, hookScript);
	}

	console.log('Skipping Hook: ' + chalk.cyan(hookName) + ' (existing user hook)');
}

function createAlias(hookersDir, aliasName) {
	var gitPath = _getGitPath(hookersDir);
	var gitKey = 'alias.' + aliasName;
	var gitVal = "'" + aliases[aliasName] + "'";

	if (debugMode) {
		console.log("Creating Alias %s - %s", chalk.cyan(gitKey), chalk.underline(gitVal));
	}

	simpleGit(gitPath).addConfig(gitKey, gitVal);
}

function removeHook(dir, name) {
	var filename = dir + '/' + name;
	if (fs.existsSync(filename) && isGitvcsHook(filename)) {
		fs.unlinkSync(dir + '/' + name);
	}
}

function removeAlias(hookersDir, vcsAlias) {
	var gitPath = _getGitPath(hookersDir);
	var gitKey = 'alias.' + vcsAlias;
	simpleGit(gitPath).raw([
		'config',
		'--unset',
		gitKey
	]);
}

function removeAliasSection(hookersDir) {
	var gitPath = _getGitPath(hookersDir);
	simpleGit(gitPath).raw([
		'config',
		'--remove-section',
		'alias'
	]);
}

function installHooks(hookersDir) {
	/** Now Attempt to install Hooks */
	var gitHooksDir = findHooksDir(hookersDir);
	if (gitHooksDir) {
		hooks.forEach(function(hookName) {
			var npmScriptName = hookName.replace(/-/g, '');
			createHook(hookersDir, gitHooksDir, hookName, npmScriptName);
		});
		console.log(chalk.green.underline('\ngit-vcs hooks are done installing\n'));
	} else {
		console.log('Can\'t find .git directory, skipping Git-VCS installation');
	}
}

function installAliases(hookersDir) {
	/** Now Attempt to install Aliases */
	var gitAliases = findAliases(hookersDir);

	if (gitAliases) {
		var aliasKeys = getConfigAliasKeys();
		if (gitAliases !== "No Alias Section Found") {
			console.log("No Alias Section Found");
			gitAliases = gitAliases.split('\n');
		}

		aliasKeys.forEach(function(vcsAlias) {
			if (gitAliases === "No Alias Section Found") {
				createAlias(hookersDir, vcsAlias);
			} else {
				var validAlias = true;
				for (var x = 0; x < gitAliases.length; x++) {
					var userAlias = gitAliases[x];
					if (!userAlias)
						continue;

					userAlias = userAlias.replace(/(^\t|\n)/g, '').trim();
					userAlias = userAlias.split(" = ")[0];

					if (userAlias === vcsAlias) {
						validAlias = false;
						break;
					}
				}

				if (validAlias)
					createAlias(hookersDir, vcsAlias);
				else
					console.log('Skipping Alias: ' + chalk.cyan(vcsAlias) + ' \t(existing user alias)');
			}
		});

		console.log(chalk.green.underline('\ngit-vcs aliases are done installing\n'));
	} else {
		console.log('Can\'t find .git config file, skipping Git-VCS installation');
	}
}

function uninstallHooks(hookersDir) {
	var gitHooksDir = findHooksDir(hookersDir);
	hooks.forEach(function(hookName) {
		removeHook(gitHooksDir, hookName);
	});
	console.log(chalk.green.underline('\ngit-vcs hooks are done uninstalling\n'));
}

function uninstallAliases(hookersDir) {
	var aliasKeys = getConfigAliasKeys();
	aliasKeys.forEach(function(vcsAlias) {
		removeAlias(hookersDir, vcsAlias);
	});
	console.log(chalk.green.underline('\ngit-vcs aliases are done uninstalling\n'));
}

module.exports = {
	installFrom: function(hookersDir, isDebug) {
		/** Confirm if we are debugging */
		confirmDebugMode(isDebug);
		try {
			/** Check if in Sub Module */
			var isInSubNodeModule = (hookersDir.match(/node_modules/g) || []).length > 1
			if (isInSubNodeModule) {
				return console.log(
					'Trying to install from sub \'node_module\' directory,',
					'skipping Git-VCS installation'
					);
			}
			installHooks(hookersDir);
			installAliases(hookersDir);
		} catch (e) {
			console.error(e);
		}
	},
	uninstallFrom: function(hookersDir, isDebug) {
		/** Confirm if we are debugging */
		confirmDebugMode(isDebug);
		try {
			uninstallHooks(hookersDir);
			uninstallAliases(hookersDir);
		} catch (e) {
			console.error(e);
		}
	}
};

function _isWin() {
	return /^win/.test(process.platform);
}

/**
 * Returns a Normalized or Relative Parent Git Path
 * @param   {[type]}  hookersDir  [description]
 * @return  {[type]}              [description]
 */
function _getGitPath(hookersDir) {
	var relativePath, packageDir, projectDir;

	// Assuming that this file is in node_modules/git-vcs
	packageDir = path.join(hookersDir, '..', '..');

	// If in debugMode, then reapply the packageDir value to local
	if (debugMode) {
		packageDir = path.join(hookersDir);
	}

	// Get project directory
	// When used in submodule, the project dir is the first .git that is found
	projectDir = findParentDir.sync(hookersDir, '.git');

	// In order to support projects with package.json in a different directory
	// than .git, find relative path from project directory to package.json
	relativePath = path.join('.', path.relative(projectDir, packageDir));

	// On Windows normalize path (i.e. convert \ to /)
	if (_isWin()) {
		console.log(chalk.red.underline("Windows OS Detected"));
		return normalize(relativePath);
	}

	return relativePath;
}