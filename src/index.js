var fs = require('fs');
var path = require('path');
var normalize = require('normalize-path');
var findParentDir = require('find-parent-dir');
var hooks = require('./hooks.json');
var pkg = require('../package.json');

function write(filename, data) {
	fs.writeFileSync(filename, data);
	fs.chmodSync(filename, parseInt('0755', 8));
}

function isHooker(filename) {
	var data = fs.readFileSync(filename, 'utf-8')
	return data.indexOf('#husky') !== -1
}

function isGhooks(filename) {
	var data = fs.readFileSync(filename, 'utf-8')
	return data.indexOf('// Generated by ghooks. Do not edit this file.') !== -1;
}

/**
 * Finds the Parent's Root Directory and verifies if
 * its a git repo. If so, it returns the path to git's
 * hooks directory.
 * @param   {[type]}  dirname  [description]
 * @return  {[type]}           [description]
 */
function findHooksDir(dirname) {
	var dir = findParentDir.sync(dirname, '.git');
	if (dir) {
		var gitDir = path.join(dir, '.git');
		var stats = fs.lstatSync(gitDir);
		if (stats.isFile()) {
			// Expect following format
			// git: pathToGit
			gitDir = fs.readFileSync(gitDir, 'utf-8').split(':')[1].trim();
			return path.join(dir, gitDir, 'hooks');
		}
		return path.join(gitDir, 'hooks');
	}
}

function getHookScript(hookName, relativePath, cmd) {
	// On Windows normalize path (i.e. convert \ to /)
	var normalizedPath = normalize(relativePath);

	// Hook script
	var arr = [
		'#!/bin/sh',
		'#hookers ' + pkg.version,
		'',
		'command_exists () {',
		'  command -v "$1" >/dev/null 2>&1',
		'}',
		'',

		'load_nvm () {',
		'  export $1=$2',
		'  [ -s "$1/nvm.sh" ] && . $1/nvm.sh',
		'  exists nvm && [ -f .nvmrc ] && nvm use',
		'}',
		'',

		'has_hook_script () {',
		'  [ -f package.json ] && cat package.json | grep -q "\\"$1\\"[[:space:]]*:"',
		'}',
		''
	];

	arr = arr.concat([
		'cd ' + normalizedPath,
		'',
		'has_hook_script ' + cmd + ' || exit 0',
		''
	]);

	// On OS X and Linux, try to use nvm if it's installed
	if (process.platform !== 'win32') {
		// ~ is unavaible, so $HOME is used
		var home = process.env.HOME

		if (process.platform === 'darwin') {
			// Add
			// Brew standard installation path /use/local/bin
			// Node standard installation path /usr/local
			// for GUI apps
			arr = arr.concat([
				'export PATH=$PATH:/usr/local/bin:/usr/local'
			]);
		}

		if (process.platform === 'darwin') {
			arr = arr.concat([
				'command_exists npm || load_nvm BREW_NVM_DIR /usr/local/opt/nvm',
				''
			]);
		}

		arr = arr.concat([
			'command_exists npm || load_nvm NVM_DIR ' + home + '/.nvm',
			''
		]);
	} else {
		// Add
		// Node standard installation path /c/Program Files/nodejs
		// for GUI apps
		arr = arr.concat([
			'export PATH="$PATH:/c/Program Files/nodejs"'
		]);
	}

	// Can't find npm message
	var npmNotFound = '> hookers - Can\'t find npm in PATH. Skipping ' + cmd + ' script in package.json';

	arr = arr.concat([
		// Test if npm is in PATH
		'command_exists npm || {',
		'  echo >&2 "' + npmNotFound + '"',
		'  exit 0',
		'}',
		'',

		// Run script
		'echo',
		'echo "> hookers - npm run -s ' + cmd + '"',
		'echo',
		'',

		'export GIT_PARAMS="$*"',
		'npm run -s ' + cmd + ' || {',
		'  echo',
		'  echo "> hookers - ' + hookName + ' hook failed (add --no-verify to bypass)"',
		'  echo "> hookers - to debug, use \'npm run precommit\'"',
		'  exit 1',
		'}',
		''
	]);

	return arr.join('\n');
}

function createHook(hookersDir, gitHooksDir, hookName, cmd) {
	var filename = path.join(gitHooksDir, hookName)

	// Assuming that this file is in node_modules/hookers
	var packageDir = path.join(hookersDir, '..', '..');

	// Get project directory
	// When used in submodule, the project dir is the first .git that is found
	var projectDir = findParentDir.sync(hookersDir, '.git');

	// In order to support projects with package.json in a different directory
	// than .git, find relative path from project directory to package.json
	var relativePath = path.join('.', path.relative(projectDir, packageDir));

	var hookScript = getHookScript(hookName, relativePath, cmd);

	// Create hooks directory if needed
	if (!fs.existsSync(gitHooksDir)) {
		fs.mkdirSync(gitHooksDir);
	}

	if (!fs.existsSync(filename)) {
		return write(filename, hookScript);
	}

	if (isGhooks(filename)) {
		console.log('migrating ghooks ' + hookName + ' script');
		return write(filename, hookScript);
	}

	if (isHooker(filename)) {
		return write(filename, hookScript);
	}

	console.log('skipping ' + hookName + ' hook (existing user hook)');
}

function removeHook(dir, name) {
	var filename = dir + '/' + name;
	if (fs.existsSync(filename) && isHooker(filename)) {
		fs.unlinkSync(dir + '/' + name);
	}
}

function installFrom(hookersDir) {
	try {
		var isInSubNodeModule = (hookersDir.match(/node_modules/g) || []).length > 1
		if (isInSubNodeModule) {
			return console.log(
				'Trying to install from sub \'node_module\' directory,',
				'skipping Git hooks installation'
			);
		}

		var gitHooksDir = findHooksDir(hookersDir);
		if (gitHooksDir) {
			hooks.forEach(function(hookName) {
				var npmScriptName = hookName.replace(/-/g, '');
				createHook(hookersDir, gitHooksDir, hookName, npmScriptName);
			});
			console.log('done\n');
		} else {
			console.log('Can\'t find .git directory, skipping Git hooks installation');
		}
	} catch (e) {
		console.error(e);
	}
}

function uninstallFrom(hookersDir) {
	try {
		var gitHooksDir = findHooksDir(hookersDir);
		hooks.forEach(function(hookName) {
			removeHook(gitHooksDir, hookName);
		});
		console.log('done\n');
	} catch (e) {
		console.error(e);
	}
}

module.exports = {
	installFrom: installFrom,
	uninstallFrom: uninstallFrom
};